<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>D&D 5e Encounter + Homebrew Stat Blocks</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 0; background: #0b0d12; color: #e9eefc; }
    .wrap { max-width: 980px; margin: 0 auto; padding: 18px; }
    h1 { font-size: 20px; margin: 0 0 10px; }
    .card { background: #121726; border: 1px solid #222a40; border-radius: 14px; padding: 14px; margin: 12px 0; }
    label { display: block; font-size: 12px; opacity: .9; margin-bottom: 6px; }
    input, select, button { width: 100%; box-sizing: border-box; padding: 10px 12px; border-radius: 10px; border: 1px solid #2a3558; background: #0f1422; color: #e9eefc; }
    button { cursor: pointer; border: 1px solid #3a4a7a; background: #1a2340; font-weight: 700; }
    button:hover { filter: brightness(1.08); }
    .grid { display: grid; grid-template-columns: repeat(6, 1fr); gap: 10px; }
    .span2 { grid-column: span 2; }
    .span3 { grid-column: span 3; }
    .span6 { grid-column: span 6; }
    .pill { display: inline-block; padding: 4px 8px; border-radius: 999px; border: 1px solid #2a3558; font-size: 12px; margin-right: 8px; margin-bottom: 6px; }
    .muted { opacity: .85; font-size: 13px; line-height: 1.35; }
    ul { margin: 10px 0 0; padding-left: 18px; }
    li { margin: 6px 0; }
    .row { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }
    .row > div { flex: 1 1 220px; }
    .warn { color: #ffd18b; }
    .ok { color: #a7ffb1; }
    .bad { color: #ff9fa6; }
    .small { font-size: 12px; opacity: .85; }
    .footer { opacity: .7; font-size: 12px; margin-top: 10px; }
    hr { border: 0; border-top: 1px solid #2a3558; margin: 10px 0; }
    details summary { cursor: pointer; font-weight: 800; }
    @media (max-width: 900px) {
      .grid { grid-template-columns: repeat(2, 1fr); }
      .span2,.span3,.span6 { grid-column: span 2; }
    }
    @media print {
      body { background: #fff; color: #000; }
      .card { border-color: #ddd; background: #fff; }
      input, select, button, .footer, #controls { display: none !important; }
      .muted { opacity: 1; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>D&D 5e Encounter Generator + Auto Homebrew Stat Blocks</h1>

    <div class="card" id="controls">
      <div class="grid">
        <div class="span2">
          <label>Party Level</label>
          <input id="partyLevel" type="number" min="1" max="20" value="5" />
        </div>
        <div class="span2">
          <label>Party Size</label>
          <input id="partySize" type="number" min="1" max="10" value="4" />
        </div>
        <div class="span2">
          <label>Difficulty</label>
          <select id="difficulty">
            <option value="easy">Easy</option>
            <option value="medium" selected>Medium</option>
            <option value="hard">Hard</option>
            <option value="deadly">Deadly</option>
          </select>
        </div>

        <div class="span3">
          <label>Theme (optional)</label>
          <select id="theme">
            <option value="any" selected>Any</option>
            <option value="undead">Undead</option>
            <option value="humanoid">Humanoid</option>
            <option value="beast">Beast</option>
            <option value="giant">Giant</option>
            <option value="fiend">Fiend</option>
            <option value="dragon">Dragon-ish</option>
            <option value="construct">Construct</option>
          </select>
          <div class="small">Filters the built-in mini monster list (edit/expand anytime).</div>
        </div>

        <div class="span3">
          <label>Style</label>
          <select id="style">
            <option value="mixed" selected>Mixed (default)</option>
            <option value="boss">Boss + Minions</option>
            <option value="horde">Horde (more bodies)</option>
          </select>
          <div class="small">Boss mode: one tougher leader + smaller support.</div>
        </div>

        <div class="span6">
          <button id="genBtn">Generate Encounter</button>
        </div>
      </div>
    </div>

    <div class="card" id="result">
      <div class="muted">Click <b>Generate Encounter</b> to get a fight.</div>
    </div>

    <div class="footer">
      Tip: Expand the monster list in the code (search for <b>MONSTERS</b>). Stat blocks are homebrew and scale to your party.
    </div>
  </div>

<script>
/** DMG XP thresholds per character by level (Easy, Medium, Hard, Deadly) */
const XP_THRESHOLDS = {
  1:[25,50,75,100], 2:[50,100,150,200], 3:[75,150,225,400], 4:[125,250,375,500],
  5:[250,500,750,1100], 6:[300,600,900,1400], 7:[350,750,1100,1700], 8:[450,900,1400,2100],
  9:[550,1100,1600,2400], 10:[600,1200,1900,2800], 11:[800,1600,2400,3600], 12:[1000,2000,3000,4500],
  13:[1100,2200,3400,5100], 14:[1250,2500,3800,5700], 15:[1400,2800,4300,6400], 16:[1600,3200,4800,7200],
  17:[2000,3900,5900,8800], 18:[2100,4200,6300,9500], 19:[2400,4900,7300,10900], 20:[2800,5700,8500,12700]
};

/** DMG XP per CR (core table) */
const CR_XP = new Map([
  ["0",10],["1/8",25],["1/4",50],["1/2",100],
  ["1",200],["2",450],["3",700],["4",1100],["5",1800],["6",2300],["7",2900],["8",3900],["9",5000],["10",5900],
  ["11",7200],["12",8400],["13",10000],["14",11500],["15",13000],["16",15000],["17",18000],["18",20000],["19",22000],["20",25000],
  ["21",33000],["22",41000],["23",50000],["24",62000],["25",75000],["26",90000],["27",105000],["28",120000],["29",135000],["30",155000],
]);

/**
 * DMG monster-number multipliers:
 * 1:1, 2:1.5, 3-6:2, 7-10:2.5, 11-14:3, 15+:4
 * Party size adjustment:
 * - party <= 2: increase multiplier one step
 * - party >= 6: decrease multiplier one step
 */
function baseMultiplier(monsterCount){
  if (monsterCount === 1) return 1;
  if (monsterCount === 2) return 1.5;
  if (monsterCount >= 3 && monsterCount <= 6) return 2;
  if (monsterCount >= 7 && monsterCount <= 10) return 2.5;
  if (monsterCount >= 11 && monsterCount <= 14) return 3;
  return 4;
}
function adjustedMultiplier(monsterCount, partySize){
  const steps = [1, 1.5, 2, 2.5, 3, 4];
  let m = baseMultiplier(monsterCount);
  let idx = steps.indexOf(m);
  if (partySize <= 2) idx = Math.min(idx + 1, steps.length - 1);
  if (partySize >= 6) idx = Math.max(idx - 1, 0);
  return steps[idx];
}

/** Mini monster list (for encounter flavor only) */
const MONSTERS = [
  // Undead
  {name:"Skeleton", cr:"1/4", tags:["undead"]},
  {name:"Zombie", cr:"1/4", tags:["undead"]},
  {name:"Ghoul", cr:"1", tags:["undead"]},
  {name:"Wight", cr:"3", tags:["undead"]},
  {name:"Wraith", cr:"5", tags:["undead"]},

  // Humanoids / Cult-ish / Soldiers
  {name:"Bandit", cr:"1/8", tags:["humanoid"]},
  {name:"Thug", cr:"1/2", tags:["humanoid"]},
  {name:"Scout", cr:"1/2", tags:["humanoid"]},
  {name:"Cultist", cr:"1/8", tags:["humanoid"]},
  {name:"Cult Fanatic", cr:"2", tags:["humanoid"]},
  {name:"Acolyte", cr:"1/4", tags:["humanoid"]},
  {name:"Veteran", cr:"3", tags:["humanoid"]},
  {name:"Knight", cr:"3", tags:["humanoid"]},
  {name:"Mage", cr:"6", tags:["humanoid"]},

  // Beasts
  {name:"Wolf", cr:"1/4", tags:["beast"]},
  {name:"Dire Wolf", cr:"1", tags:["beast"]},
  {name:"Brown Bear", cr:"1", tags:["beast"]},

  // Giants / Brutes
  {name:"Ogre", cr:"2", tags:["giant"]},
  {name:"Troll", cr:"5", tags:["giant"]},
  {name:"Hill Giant", cr:"5", tags:["giant"]},

  // Fiends
  {name:"Imp", cr:"1", tags:["fiend"]},
  {name:"Spined Devil", cr:"2", tags:["fiend"]},
  {name:"Barbed Devil", cr:"5", tags:["fiend"]},

  // Dragon-ish (stand-ins)
  {name:"Wyvern", cr:"6", tags:["dragon"]},
  {name:"Young White Dragon", cr:"6", tags:["dragon"]},

  // Constructs
  {name:"Animated Armor", cr:"1", tags:["construct"]},
  {name:"Helmed Horror", cr:"4", tags:["construct"]},
];

/** Helpers */
function randInt(min, max){ return Math.floor(Math.random()*(max-min+1))+min; }
function pick(arr){ return arr[Math.floor(Math.random()*arr.length)]; }
function sum(arr){ return arr.reduce((a,b)=>a+b,0); }
function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }
function avgDie(die){ return (die + 1) / 2; }

function budgetFor(level, size, diff){
  const idx = {easy:0, medium:1, hard:2, deadly:3}[diff];
  const per = XP_THRESHOLDS[level]?.[idx];
  if (!per) throw new Error("Party level must be 1–20.");
  return per * size;
}
function xpForCR(cr){
  const xp = CR_XP.get(cr);
  if (xp == null) throw new Error("Unknown CR: " + cr);
  return xp;
}
function filterByTheme(theme){
  if (theme === "any") return MONSTERS.slice();
  return MONSTERS.filter(m => m.tags.includes(theme));
}
function describeDifficultyRatio(adjustedXp, budget){
  const ratio = adjustedXp / budget;
  if (ratio < 0.85) return {label:"Below target", cls:"warn"};
  if (ratio <= 1.15) return {label:"On target", cls:"ok"};
  return {label:"Spicy (over target)", cls:"bad"};
}

/** Generate encounter: try many random attempts and keep best fit to XP budget */
function generateEncounter({level, size, difficulty, theme, style}){
  const pool = filterByTheme(theme);
  if (pool.length === 0) throw new Error("No monsters for this theme. Expand MONSTERS list.");

  const budget = budgetFor(level, size, difficulty);

  let minCount = 1, maxCount = 6;
  if (style === "boss") { minCount = 2; maxCount = 6; }
  if (style === "horde") { minCount = 4; maxCount = 10; }

  const attempts = 900;
  let best = null;

  for (let i=0;i<attempts;i++){
    const count = randInt(minCount, maxCount);
    let picks = [];

    if (style === "boss") {
      const sorted = pool.slice().sort((a,b)=>xpForCR(a.cr)-xpForCR(b.cr));
      const bossCandidates = sorted.slice(Math.floor(sorted.length*0.65));
      const boss = pick(bossCandidates.length ? bossCandidates : sorted);
      picks.push(boss);

      const minionPool = sorted.slice(0, Math.max(1, Math.floor(sorted.length*0.6)));
      while (picks.length < count) picks.push(pick(minionPool));
    } else if (style === "horde") {
      const low = pool.slice().sort((a,b)=>xpForCR(a.cr)-xpForCR(b.cr));
      const lowPool = low.slice(0, Math.max(1, Math.floor(low.length*0.7)));
      for (let k=0;k<count;k++) picks.push(pick(lowPool));
    } else {
      for (let k=0;k<count;k++) picks.push(pick(pool));
    }

    const rawXp = sum(picks.map(m=>xpForCR(m.cr)));
    const mult = adjustedMultiplier(picks.length, size);
    const adjustedXp = rawXp * mult;

    const diffFromTarget = Math.abs(adjustedXp - budget);
    const overPenalty = adjustedXp > budget ? (adjustedXp - budget) * 1.15 : 0;
    const score = diffFromTarget + overPenalty;

    if (!best || score < best.score){
      best = {picks, rawXp, mult, adjustedXp, budget, score, style, theme};
    }
  }

  const counts = new Map();
  for (const m of best.picks) counts.set(m.name, (counts.get(m.name) || 0) + 1);

  const lines = [];
  for (const [name, qty] of counts.entries()){
    const sample = best.picks.find(x => x.name === name);
    lines.push({name, qty, cr: sample.cr, xpEach: xpForCR(sample.cr), tags: sample.tags});
  }
  lines.sort((a,b)=>xpForCR(b.cr)-xpForCR(a.cr));

  return { ...best, lines };
}

/* =========================
   HOME BREW STAT BLOCKS
   ========================= */

function baselineByLevel(level){
  const pb = level <= 4 ? 2 : level <= 8 ? 3 : level <= 12 ? 4 : level <= 16 ? 5 : 6;
  const atk = pb + (level <= 4 ? 3 : level <= 10 ? 4 : 5);
  const dc  = 8 + pb + (level <= 4 ? 3 : level <= 10 ? 4 : 5);
  return { pb, atk, dc };
}
function difficultyMods(diff){
  if (diff === "easy")   return { hp: 0.85, dmg: 0.85, ac: -1 };
  if (diff === "medium") return { hp: 1.00, dmg: 1.00, ac: 0 };
  if (diff === "hard")   return { hp: 1.15, dmg: 1.15, ac: +1 };
  return                 { hp: 1.30, dmg: 1.30, ac: +2 };
}

const THEME_TEMPLATES = {
  undead: {
    senses: "darkvision 60 ft.",
    resist: "necrotic (elite/boss); bludgeoning, piercing, and slashing from nonmagical attacks (minions only)",
    imm: "poison",
    traits: [
      {name:"Undead Fortitude (1/Turn)", desc:"If damage reduces this creature to 0 hit points, it makes a Con save (DC 5 + damage taken). On a success, it drops to 1 hit point instead."}
    ],
    specialMove(level, dc){
      return {name:"Grave Chill (Recharge 5–6)", desc:`Each creature of the creature’s choice within 10 feet must succeed on a DC ${dc} Constitution saving throw or take necrotic damage and can’t regain hit points until the start of its next turn.`};
    }
  },
  humanoid: {
    senses: "passive Perception 12",
    traits: [
      {name:"Pack Tactics", desc:"The creature has advantage on an attack roll against a target if at least one of the creature’s allies is within 5 feet of the target and the ally isn’t incapacitated."}
    ],
    specialMove(level, dc){
      return {name:"Commanding Shout (Recharge 6)", desc:"Up to two allies that can hear the creature may use their reactions to move up to half their speed and make one weapon attack."};
    }
  },
  beast: {
    senses: "passive Perception 13",
    traits: [
      {name:"Keen Senses", desc:"The creature has advantage on Wisdom (Perception) checks that rely on smell or hearing."}
    ],
    specialMove(level, dc){
      return {name:"Savage Pounce", desc:`If the creature moves at least 20 feet straight toward a target and then hits it with a melee attack on the same turn, the target must succeed on a DC ${dc} Strength saving throw or be knocked prone.`};
    }
  },
  giant: {
    senses: "passive Perception 11",
    traits: [
      {name:"Brutal", desc:"On a hit, the creature deals extra damage equal to its proficiency bonus (included in the damage)."}
    ],
    specialMove(level, dc){
      const atk = baselineByLevel(level).atk;
      return {name:"Hurl Debris (Recharge 5–6)", desc:`Ranged Weapon Attack: +${atk} to hit, range 60/180 ft., one target. Hit: bludgeoning damage, and the target must succeed on a DC ${dc} Strength saving throw or be pushed 10 feet.`};
    }
  },
  fiend: {
    senses: "darkvision 120 ft.",
    resist: "fire",
    traits: [
      {name:"Hellish Resistance", desc:"The creature has resistance to fire damage."}
    ],
    specialMove(level, dc){
      return {name:"Infernal Rebuke (Reaction, Recharge 6)", desc:`When hit by an attack, the attacker must make a DC ${dc} Dexterity saving throw, taking fire damage on a failed save, or half as much on a success.`};
    }
  },
  dragon: {
    senses: "darkvision 120 ft., blindsight 10 ft.",
    traits: [
      {name:"Frightful Presence (1/Day)", desc:"Each creature of the dragon’s choice within 30 feet that can see it must succeed on a Wisdom saving throw or be frightened for 1 minute (repeat the save at the end of its turns)."}
    ],
    specialMove(level, dc){
      return {name:"Breath Weapon (Recharge 5–6)", desc:`The creature exhales energy in a 30-foot line (5 feet wide) or 15-foot cone (your choice). Each creature in the area must make a DC ${dc} saving throw, taking elemental damage on a failed save, or half as much on a success.`};
    }
  },
  construct: {
    senses: "darkvision 60 ft.",
    imm: "poison, psychic",
    traits: [
      {name:"Construct Nature", desc:"The creature doesn’t need to eat, drink, breathe, or sleep."}
    ],
    specialMove(level, dc){
      return {name:"Overclock (Recharge 6)", desc:"Until the end of its next turn, the creature’s speed increases by 10 feet and it makes one additional attack when it takes the Attack action."};
    }
  },
  any: {
    senses: "passive Perception 12",
    traits: [],
    specialMove(level, dc){ return null; }
  }
};

function statsFromRole({level, difficulty, role, isBoss=false}){
  const { atk, dc, pb } = baselineByLevel(level);
  const mods = difficultyMods(difficulty);

  const hpBase =
    role === "minion" ? (level * 8 + 6) :
    role === "standard" ? (level * 12 + 12) :
    role === "elite" ? (level * 18 + 24) :
    (level * 26 + 40);

  const acBase =
    role === "minion" ? 12 :
    role === "standard" ? 13 :
    role === "elite" ? 15 :
    17;

  const dprBase =
    role === "minion" ? (level * 1.6 + 3) :
    role === "standard" ? (level * 2.2 + 6) :
    role === "elite" ? (level * 3.0 + 10) :
    (level * 4.0 + 16);

  let hp = Math.round(hpBase * mods.hp * (isBoss ? 1.15 : 1));
  let ac = acBase + mods.ac + (isBoss ? 1 : 0);
  let dpr = Math.round(dprBase * mods.dmg * (isBoss ? 1.15 : 1));

  return { hp: clamp(hp,10,420), ac: clamp(ac,10,22), atk, dc, pb, dpr: clamp(dpr,3,120) };
}

function makeAttackLine({name, atkBonus, reach="5 ft.", target="one target", dmgAvg, dmgType="slashing"}){
  const dieOptions = [4,6,8,10,12];
  let best = {expr:"1d6", avg:3.5};
  for (const die of dieOptions){
    for (let n=1;n<=6;n++){
      const avg = n * avgDie(die);
      if (Math.abs(avg - dmgAvg) < Math.abs(best.avg - dmgAvg)) best = {expr:`${n}d${die}`, avg};
    }
  }
  let mod = Math.round(dmgAvg - best.avg);
  const dmgExpr = `${best.expr}${mod !== 0 ? (mod>0?` + ${mod}`:` - ${Math.abs(mod)}`) : ""}`;
  return `<b>${name}.</b> Melee Weapon Attack: +${atkBonus} to hit, reach ${reach}, ${target}. Hit: ${dmgExpr} ${dmgType} damage.`;
}

function deriveRole(line){
  if (line.qty >= 6) return "minion";
  if (line.qty >= 3) return "standard";
  return "elite";
}

function buildHomebrewStatBlock({baseName, theme, level, difficulty, role, qty, isBoss=false}){
  const t = THEME_TEMPLATES[theme] || THEME_TEMPLATES.any;
  const s = statsFromRole({level, difficulty, role, isBoss});
  const size = isBoss ? "Large" : "Medium";
  const type =
    theme === "undead" ? "undead" :
    theme === "beast" ? "beast" :
    theme === "giant" ? "giant" :
    theme === "fiend" ? "fiend" :
    theme === "dragon" ? "dragon" :
    theme === "construct" ? "construct" :
    "humanoid";

  const name = isBoss ? `${baseName}, Encounter Boss` : `${baseName}`;
  const speed = isBoss ? "40 ft." : (role === "minion" ? "30 ft." : "30 ft.");

  const str = clamp(10 + (isBoss ? 8 : role === "elite" ? 5 : role === "minion" ? 1 : 3) + (theme==="giant"?4:0), 6, 24);
  const dex = clamp(10 + (theme==="beast"?3:0) + (role==="minion"?2:0) - (theme==="giant"?1:0), 6, 20);
  const con = clamp(12 + (isBoss ? 6 : role==="elite"?4: role==="minion"?1:2), 8, 24);
  const int = clamp(theme==="beast"?3: (theme==="construct"?6:10), 1, 16);
  const wis = clamp(theme==="undead"?12:11, 6, 18);
  const cha = clamp(theme==="fiend"||theme==="dragon"?14:10, 4, 20);

  const attacks = isBoss ? 2 : (role === "elite" ? 2 : 1);
  const perHit = Math.max(2, Math.round(s.dpr / attacks));

  const dmgType =
    theme === "undead" ? "necrotic" :
    theme === "fiend" ? "fire" :
    theme === "construct" ? "force" :
    theme === "beast" ? "piercing" :
    theme === "dragon" ? "slashing" :
    "slashing";

  const actionLines = [];
  actionLines.push(makeAttackLine({ name:"Strike", atkBonus:s.atk, dmgAvg:perHit, dmgType }));
  if (attacks >= 2) actionLines.push(makeAttackLine({ name:"Second Attack", atkBonus:s.atk, dmgAvg:perHit, dmgType }));

  const special = (isBoss || role === "elite") ? t.specialMove(level, s.dc) : null;

  const traits = [];
  for (const tr of (t.traits || [])){
    if (role === "minion" && Math.random() < 0.6) continue;
    traits.push(tr);
  }
  if (theme === "dragon" && (isBoss || role === "elite")){
    traits.push({name:"Flyby", desc:"The creature doesn’t provoke opportunity attacks when it flies out of an enemy’s reach."});
  }

  const resistLine = (() => {
    if (!t.resist) return "";
    if (role === "minion" && theme === "undead") return `<div class="muted"><b>Resistances</b> bludgeoning, piercing, and slashing from nonmagical attacks</div>`;
    if (role !== "minion") return `<div class="muted"><b>Resistances</b> ${t.resist}</div>`;
    return "";
  })();

  return `
    <div class="card" style="margin-top:10px">
      <div style="display:flex;justify-content:space-between;gap:10px;flex-wrap:wrap">
        <div>
          <div style="font-size:16px;font-weight:800">${name}${qty>1 ? ` (x${qty})` : ""}</div>
          <div class="muted">${size} ${type}, unaligned</div>
        </div>
        <div class="muted">
          <div><b>AC</b> ${s.ac}</div>
          <div><b>HP</b> ${s.hp}</div>
          <div><b>Speed</b> ${speed}</div>
        </div>
      </div>

      <div class="muted" style="margin-top:8px">
        <b>STR</b> ${str} &nbsp; <b>DEX</b> ${dex} &nbsp; <b>CON</b> ${con} &nbsp;
        <b>INT</b> ${int} &nbsp; <b>WIS</b> ${wis} &nbsp; <b>CHA</b> ${cha}
      </div>

      <div class="muted" style="margin-top:8px">
        <b>Proficiency Bonus</b> +${s.pb} &nbsp; <b>Attack Bonus</b> +${s.atk} &nbsp; <b>Save DC</b> ${s.dc}
      </div>

      ${resistLine}
      ${t.imm ? `<div class="muted"><b>Immunities</b> ${t.imm}</div>` : ""}
      ${t.senses ? `<div class="muted"><b>Senses</b> ${t.senses}</div>` : ""}

      ${traits.length ? `
        <hr>
        <div class="muted"><b>Traits</b></div>
        <ul>${traits.map(x=>`<li><b>${x.name}.</b> ${x.desc}</li>`).join("")}</ul>
      ` : ""}

      <hr>
      <div class="muted"><b>Actions</b></div>
      <ul>
        ${actionLines.map(a=>`<li>${a}</li>`).join("")}
        ${special ? `<li><b>${special.name}.</b> ${special.desc}</li>` : ""}
        ${isBoss ? `<li><b>Relentless (1/Day).</b> When reduced to 0 hit points, the boss drops to 1 hit point instead.</li>` : ""}
      </ul>
    </div>
  `;
}

/* =========================
   UI
   ========================= */

const result = document.getElementById("result");

function renderEncounter(enc, {level, size, difficulty, theme, style}){
  const vibe = describeDifficultyRatio(enc.adjustedXp, enc.budget);

  // Boss name = highest CR entry (boss style only)
  let bossName = null;
  if (style === "boss") {
    const sorted = enc.lines.slice().sort((a,b)=>xpForCR(b.cr)-xpForCR(a.cr));
    bossName = sorted[0]?.name || null;
  }

  const statBlocksHtml = enc.lines.map(line => {
    const role = (style === "boss" && line.name === bossName) ? "boss" : deriveRole(line);
    const isBoss = role === "boss";
    const autoTheme = (theme === "any" && line.tags?.length) ? line.tags[0] : theme;

    return buildHomebrewStatBlock({
      baseName: line.name,
      theme: autoTheme || "any",
      level,
      difficulty,
      role,
      qty: line.qty,
      isBoss
    });
  }).join("");

  result.innerHTML = `
    <div class="row">
      <div>
        <span class="pill">Level ${level}</span>
        <span class="pill">${size} players</span>
        <span class="pill">${difficulty.toUpperCase()}</span>
        <span class="pill">Theme: ${theme}</span>
        <span class="pill">Style: ${style}</span>
      </div>
    </div>

    <div style="margin-top:10px" class="muted">
      <b>XP Budget:</b> ${enc.budget.toFixed(0)}<br/>
      <b>Raw XP:</b> ${enc.rawXp.toFixed(0)}<br/>
      <b>Multiplier:</b> ×${enc.mult} (for ${enc.picks.length} monsters, party-size adjusted)<br/>
      <b>Adjusted XP:</b> ${enc.adjustedXp.toFixed(0)} — <span class="${vibe.cls}"><b>${vibe.label}</b></span>
    </div>

    <ul>
      ${enc.lines.map(x => `
        <li>
          <b>${x.qty}× ${x.name}</b>
          <span class="muted"> (CR ${x.cr}, ${x.xpEach} XP each)</span>
          <span class="small"> — ${(x.tags || []).join(", ")}</span>
        </li>
      `).join("")}
    </ul>

    <details class="card" style="margin-top:12px">
      <summary>Homebrew Stat Blocks (tap to open)</summary>
      <div class="muted" style="margin-top:8px">
        Scaled to Level ${level} / ${difficulty.toUpperCase()}.
      </div>
      ${statBlocksHtml}
    </details>

    <div class="muted" style="margin-top:10px">
      DM tip: To make it scarier without changing XP, add terrain pressure (cover, choke points, darkness, hazards).
    </div>
  `;
}

document.getElementById("genBtn").addEventListener("click", () => {
  try {
    const level = Number(document.getElementById("partyLevel").value);
    const size = Number(document.getElementById("partySize").value);
    const difficulty = document.getElementById("difficulty").value;
    const theme = document.getElementById("theme").value;
    const style = document.getElementById("style").value;

    if (!Number.isFinite(level) || level < 1 || level > 20) throw new Error("Party level must be 1–20.");
    if (!Number.isFinite(size) || size < 1 || size > 10) throw new Error("Party size must be 1–10.");

    const enc = generateEncounter({level, size, difficulty, theme, style});
    renderEncounter(enc, {level, size, difficulty, theme, style});
  } catch (e) {
    result.innerHTML = `<div class="muted"><span class="bad"><b>Error:</b></span> ${e.message}</div>`;
  }
});

// Auto-generate once on load
document.getElementById("genBtn").click();
</script>
</body>
</html>
